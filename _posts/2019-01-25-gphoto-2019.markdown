---
layout:     post                    # 使用的布局（不需要改）
title:      gphoto                # 标题 
subtitle:    第一篇                  #副标题
date:       2019-09-21              # 时间
author:     BY Edlward              # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - GPHOTO2
---
### MTP USB数据抓包分析
[MTP工具](https://github.com/Edlward/usbmtp_dissector)  
[MTP工具](https://github.com/Edlward/mtp-tools)  

[Linux-创建rc红外遥控平台设备,实现重复功能(2)](https://www.cnblogs.com/lifexy/p/9783914.html)  

### IR Control
[The open hardware project to build an inexpensive and customizable infrared remote control for Nikon cameras](http://www.bigmike.it/ircontrol/)  
[尼康 ML - L3 DIY IR Remote Hack Part I](https://bayesianadventures.wordpress.com/2013/08/09/nikon-ml-l3-ir-remote-hack/)  
[test](http://goughlui.com/2013/12/06/teardown-and-project-clone-nikon-ml-l3-ir-remote-and-emulation/)  
[ RC-Servo-Tester-/MCU_Source/Servo_Tester_v4/Source/ir_protocol.c ](https://github.com/mocona05/RC-Servo-Tester-/blob/b9d6ad4afbf6dd28f95d15331f7faaa572c3ac96/MCU_Source/Servo_Tester_v4/Source/ir_protocol.c)  




### Node JS
[libgphoto2的Node.js包装器](https://www.npmjs.com/package/gphoto2)  
[node-gphoto2](https://github.com/lwille/node-gphoto2.git)  
[ts-gphoto2-driver](https://github.com/TypedProject/ts-gphoto2-driver)  

### libtdl
动态链接库
[libtdl](https://www.gnu.org/software/libtool/manual/html_node/Libltdl-interface.html)  

```
Install libgphoto2 and gphoto2 from source on Raspberry Pi
https://hyfrmn.wordpress.com/2015/02/03/install-libgphoto2-and-gphoto2-from-source-on-raspberry-pi/
FEBRUARY 3, 2015HYFRMN
I wanted to control my camera, a Nikon D5300, through my raspberry pi. Unfortunately the version of libgphoto2 installed by default has a known bug that causes it to break. The bug is fixed in the latest version, so I decided to download and compile the latest versions. Here are the steps I used.
First install the dependencies:

# Install Dependencies
sudo apt-get install libltdl-dev libusb-dev libusb-1.0 libexif-dev libpopt-dev
Next download the latest stable versions:

# Download Latest libgphoto2
wget http://downloads.sourceforge.net/project/gphoto/libgphoto/2.5.7/libgphoto2-2.5.7.tar.gz
# Download Latest gphoto2
wget http://downloads.sourceforge.net/project/gphoto/gphoto/2.5.6/gphoto2-2.5.6.tar.gz

Next we will unpack the files, configure the builds, compile the library and install it.

tar -xvzf libgphoto2-2.5.7.tar.gz
cd libgphoto2-2.5.7
./configure
make #This is going to take some time. Go get a cup of coffee.
sudo make install
Finally repeat the same process with gphoto2.

tar -xvzf gphoto2-2.5.6.tar.gz
cd gphoto2-2.5.6
./configure
make #Much faster then libgphoto2
sudo make install
If everything went well, you should be able to plug in your camera, and connect using the following.

gphoto2 --auto-detect


```




```
ffmpeg+ffserver搭建流媒体服务器
ffmpeg和ffserver配合使用可以实现实时的流媒体服务。
一、理解
里边主要有如下四个东西，搞清楚他们之间的关系就差不多明白了。
1. ffmpeg
2. ffserver
3. ffserver.conf
4. feed1.ffm

1. ffmpeg，负责媒体文件的transcode工作，把你服务器上的源媒体文件转换成要发送出去的流媒体文件。
2. ffserver，负责响应客户端的流媒体请求，把流媒体数据发送给客户端。
3. ffserver.conf，ffserver启动时的配置文件，在这个文件中主要是对网络协议，缓存文件feed1.ffm（见下述）和要发送的流媒体文件的格式参数做具体的设定。
4. feed1.ffm，可以看成是一个流媒体数据的缓存文件，ffmpeg把转码好的数据发送给ffserver，如果没有客户端连接请求，ffserver把数据缓存到该文件中。

二、http的建立流程
1. 配置ffserver.conf文件（初次接触可以参考ffmpeg源码中的doc/ffserver.conf，里边有详细的注释）
如下写一个示例
Port 10535
RTSPPort 5454
BindAddress 0.0.0.0、
MaxHTTPConnections 2000
MaxClients 1000
MaxBandwidth 1000
CustomLog -
NoDaemon

#实时流数据配置(参考源码ffmpeg/test/下的ffserver.conf)
File /tmp/feed1.ffm
FileMaxSize 1M
ACL allow 127.0.0.1

Feed feed1.ffm
Format avi
#
BitExact
DctFastint
IdctSimple
VideoFrameRate 10
VideoSize 352x288
VideoBitRate 100
VideoGopSize 30
NoAudio

PreRoll 10
StartSendOnKey
MaxTime 100

#已经存在的文件而非实时流

2、如何实现播放
（1）实时流用http传输
如果传输硬盘上的文件，则：
ffserver -f myfile/ffmpeg0.8.9/ffserver.conf & ffmpeg -i inputfile(输入文件) http://localhost:10535/feed1.ffm
如何传输摄像头捕获的实时流，则：
ffserver -f myfile/ffmpeg0.8.9/ffserver.conf & ffmpeg -f video4linux2 -framerate 30 -i /dev/video0 http://127.0.0.1:8090/feed1.ffm

启动ffserver和ffmpeg。ffserver先于ffmpeg启动，它在启动的时候需要加参数-f指定其配置文件。ffserver启动后，feed1.ffm就会被创建，这时如果你打开feed1.ffm看看，会发现feed1.ffm开始的部分已经写入了内 容，你可以找到关键字ffm以及向客户端传送流的配置信息，在feed1.ffm做缓冲用的时候，这些信息是不会被覆盖掉的，就把它们理解为 feed1.ffm文件的头吧。

ffserver启动后，ffmpeg启动，它启动时加的一个关键参数就是“http://ip:10535/feed1.ffm”，其中ip是运行 ffserver主机的ip，如果ffmpeg和ffserver都在同一系统中运行的话，用localhost也行。ffmpeg启动后会与 ffserver建立一个连接(短暂的连接)，通过这第一次的连接，ffmpeg从ffserver那里获取了向客户端输出流的配置，并把这些配置作为自 己编码输出的配置，然后ffmpeg断开了这次连接，再次与ffserver建立连接(长久的连接)，利用这个连接ffmpeg会把编码后的数据发送给 ffserver。

如果你观察ffserver端的输出就会发现这段时间会出现两次HTTP的200，这就是两次连接的过程。

ffmpeg从摄像头获取数据后，按照输出流的编码方式编码，然后发送给ffserver，ffserver收到ffmpeg的数据后，如果网络上 没有播放的请求，就把数据写入feed1.ffm中缓存，写入时把数据加上些头信息然后分块，每块4096B（每块也有结构），当feed1.ffm的大 小到了ffserver.conf中规定的大小后，就会从文件开始（跳过头）写入，覆盖旧的数据。直到网络上有播放的请求，ffserver从 feed1.ffm中读取数据，发送给客户端。

(2)本地文件用http传输
ffserver -f /etc/ffserver.conf
用命令启动ffserver，然后用ffplay http://ip:port/test.flv,或者在vlc中输入以上网址也可实现播放。

(3)本地文件用rtsp传输
ffserver -f /etc/ffserver.conf
用命令启动ffserver，然后用ffplay rtsp://ip:port/rtsp.mpg，或者在vlc中输入以上网址也可实现播放。
备注：在做测试的时候，用rtsp不能传输flv文件。

```

```
gPhoto2是一个免费软件，提供了在类Unix系统上通过终端来控制数码相机的功能，开发队伍来自世界各地的自愿者，现在已支持超过1700多款机 型。可以运行在Linux, FreeBSD, NetBSD, MacOS X等系统上。同时在大部分发行版的软件仓库中都有。通过Picture Transfer Protocol (PTP) 协议来和相机通讯。
 
    安装libgphoto2 是为了，使用到gphoto2的 API  链接地址：http://www.gphoto.org/doc/api/gphoto2-camera_8h.html ，即可以调用libgphoto2的库来进行编程。而gphoto2只是提供命令行的控制照相机。gphoto2官网的文档http://gphoto.sourceforge.net/doc/manual/ref-gphoto2-cli.html。
当然，你可以安装gphoto2的图形界面gtkam。
一，安装 gphoto2 ：
$sudo apt-get install gphoto2
$ sudo apt-get install gtkam
二、将相机用USB线与电脑连接，最好使用有源的USB HUB，以免供电不足，打开相机电源，执行命令，查看 gphoto2 是否识别到了照相机：
$ gphoto2 --auto-detect
就会看到 USB PTP Class Camera  usb：001,002

三、拍照
 $gphoto2 --capture-image 拍照
 $ gphoto2  --capture-image-and-download 拍照后传到电脑的当前目录下
  拍照时可能会报错，关于错误解答，请看官网链接：http://www.gphoto.org/doc/manual/FAQ.html#FAQ-could-not-claim-USB

四，libgphoto2 安装
$ sudo apt-get install libgphoto2-2-dev
 安装成功之后，就可以使用 api编程的了
五，C++模板
#include < gphoto2/gphoto2-camera.h >
// C++ includes
#include < cstdlib >
#include < cstdio >

// C includes
#include < fcntl.h >

// Class header include
#include "../include/gphoto2_handler.hpp"
void errorCallback(GPContext *context, const char *format, va_list args, void *data);
void messageCallback(GPContext *context, const char *format, va_list args, void *data);
GPhoto2Handler::GPhoto2Handler()
{
    gp_camera_new(&camera);
    context = gp_context_new();

    gp_context_set_error_func(context, errorCallback, NULL);
    gp_context_set_message_func(context, messageCallback, NULL);

    int return_code = gp_camera_init(camera, context);
    if (return_code < GP_OK)
    {
        ROS_ERROR("%s", "No camera detected.");
        gp_camera_free(camera);
    }
}
std::string GPhoto2Handler::takePicture()
{
    std::string empty_filename;

    CameraFilePath camera_file_path;
    int return_code = gp_camera_capture(camera, GP_CAPTURE_IMAGE, &camera_file_lpath, context);

    if (return_code)
    {
        ROS_ERROR("%s", "Could not capture the image from the camera.");
        return empty_filename;
    }

    int file_descriptor = open(camera_file_path.name, O_CREAT | O_WRONLY, 0644);

    CameraFile *file;
    return_code = gp_file_new_from_fd(&file, file_descriptor);

    if (return_code)
    {
        ROS_ERROR("%s", "Could not create a new file to store the image from the camera.");
        return empty_filename;
    }
    return_code = gp_camera_file_get(camera,
                                     camera_file_path.folder,
                                     camera_file_path.name,
                                     GP_FILE_TYPE_NORMAL,
                                     file,
                                     context);
    if (return_code)
    {
        ROS_ERROR("%s", "Could not download the captured image from the camera.");
        return empty_filename;
    }

    return_code = gp_camera_file_delete(camera,
                                        camera_file_path.folder,
                                        camera_file_path.name,
                                        context);
    if (return_code)
    {
        ROS_WARN("%s", "Could not delete the captured image from the camera.");
    }

    gp_file_free(file);

    std::string picture_filename(camera_file_path.name);
    return picture_filename;
}


代码可能看糊涂，就大概总结一下吧：
关键地方就下面几个函数：
//自动拍照功能，获取图像
gp_camera_capture(camera, GP_CAPTURE_IMAGE, &camera_file_lpath, context);
//获取打开文件的权限
int file_descriptor = open(camera_file_path.name, O_CREAT | O_WRONLY, 0644);
//获取图像路径和文件名
eturn_code = gp_camera_file_get(camera,
                                     camera_file_path.folder,
                                     camera_file_path.name,
                                     GP_FILE_TYPE_NORMAL,
                                     file,
                                     context);
获取这个路径之后，就可以下载照片到自己的电脑上了，保存照片电脑上的操作可以采用CV::write()操作

//删掉照相机中的这个图像，可以不删掉，让它保持在照相机中
return_code = gp_camera_file_delete(camera,
                                        camera_file_path.folder,
                                        camera_file_path.name,
                                        context);
具体函数，可以看以上官网说明。


```
