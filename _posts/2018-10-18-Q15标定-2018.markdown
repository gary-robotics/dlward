---
layout:     post                    # 使用的布局（不需要改）
title:      Q15标定                # 标题 
subtitle:    第一篇                  #副标题
date:       2018-10-18              # 时间
author:     BY Edlward              # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 电机
---

### 在应用DSP时，其实硬件一般都问题不大，主要的是软件，是算法！下面的关于DSP运算的精华但愿有些价值！

一 ＤＳＰ定点算数运算

1 数的定标

在定点DSP芯片中，采用定点数进行数值运算，其操作数一般采用整型数来表示。一个整型数的最大表示范围取决于DSP芯片所给定的字长，一般为16位或24位。显然，字长越长，所能表示的数的范围越大，精度也越高。如无特别说明，本书均以16位字长为例。

DSP芯片的数以2的补码形式表示。每个16位数用一个符号位来表示数的正负，0表示数值为正，l则表示数值为负。其余15位表示数值的大小。因此，

二进制数0010000000000011b=8195

二进制数1111111111111100b= -4

对DSP芯片而言，参与数值运算的数就是16位的整型数。但在许多情况下，数学运算过程中的数不一定都是整数。那么，DSP芯片是如何处理小数的呢？应该说，DSP芯片本身无能为力。那么是不是说DSP芯片就不能处理各种小数呢？当然不是。这其中的关键就是由程序员来确定一个数的小数点处于16位中的哪一位。这就是数的定标。

通过设定小数点在16位数中的不同位置，就可以表示不同大小和不同精度的小数了。数的定标有Q表示法和S表示法两种。表1.1列出了一个16位数的16种Q表示、S表示及它们所能表示的十进制数值范围。

从表1.1可以看出，同样一个16位数，若小数点设定的位置不同，它所表示的数也就不同。例如，

16进制数2000H=8192，用Q0表示

16进制数2000H=0.25，用Q15表示

但对于DSP芯片来说，处理方法是完全相同的。

从表1.1还可以看出，不同的Q所表示的数不仅范围不同，而且精度也不相同。Q越大，数值范围越小，但精度越高；相反，Q越小，数值范围越大，但精度就越低。例如，Q0 的数值范围是一32768到+32767，其精度为1，而Q15的数值范围为-1到0.9999695，精度为1/32768=0.00003051。因此，对定点数而言，数值范围与精度是一对矛盾，一个变量要想能够表示比较大的数值范围，必须以牺牲精度为代价；而想精度提高，则数的表示范围就相应地减小。在实际的定点算法中，为了达到最佳的性能，必须充分考虑到这一点。

浮点数与定点数的转换关系可表示为：

浮点数(x)转换为定点数(xq)：xq=(int)x* 2Q

定点数(xq)转换为浮点数(x)：x=(float)xq*2-Q

例如，浮点数x=0.5，定标Q=15，则定点数xq=L0.5*32768J=16384，式中LJ表示下取整。反之，一个用Q=15表示的定点数16384，其浮点数为163幼*2-15=16384/32768=0.5。浮点数转换为定点数时，为了降低截尾误差，在取整前可以先加上0.5。

表1.1 Q表示、S表示及数值范围

Q表示 S表示 十进制数表示范围

Q15 S0.15 -1≤x≤0.9999695

Q14 S1.14 -2≤x≤1.9999390

Q13 S2.13 -4≤x≤3.9998779

Q12 S3.12 -8≤x≤7.9997559

Q11 S4.11 -16≤x≤15.9995117

Q10 S5.10 -32≤x≤31.9990234

Q9 S6.9 -64≤x≤63.9980469

Q8 S7.8 -128≤x≤127.9960938

Q7 S8.7 -256≤x≤255.9921875

Q6 S9.6 -512≤x≤511.9804375

Q5 S10.5 -1024≤x≤1023.96875

Q4 S11.4 -2048≤x≤2047.9375

Q3 S12.3 -4096≤x≤4095.875

Q2 S13.2 -8192≤x≤8191.75

Q1 S14.1 -16384≤x≤16383.5

Q0 S15.0 -32768≤x≤32767

2 高级语言：从浮点到定点

我们在编写DSP模拟算法时，为了方便，一般都是采用高级语言(如C语言)来编写模拟程序。程序中所用的变量一般既有整型数，又有浮点数。如例1.1程序中的变量i是整型数，而pi是浮点数，hamwindow则是浮点数组。

例1.1 256点汉明窗计算

int i；+

float pi=3.14l59；

float hamwindow[256]；

for(i=0；i<256；i++) hamwindow=0.54-0.46*cos(2.0*pi*i/255)；

如果我们要将上述程序用某种足点DSP芯片来实现，则需将上述程序改写为DSP芯片的汇编语言程序。为了DSP程序调试的方便及模拟定点DSP实现时的算法性能，在编写DSP汇编程序之前一般需将高级语言浮点算法改写为高级语言定点算法。下面我们讨论基本算术运算的定点实现方法。

2.1 加法/减法运算的C语言定点摸拟

设浮点加法运算的表达式为：

float x，y，z；

z=x+y；

将浮点加法/减法转化为定点加法/减法时最重要的一点就是必须保证两个操作数的定标

temp=x+temp；

z=temp>>(Qx-Qz)，若Qx>=Qz

z=temp<<(Qz-Qx)，若Qx<=Qz

例1.4结果超过16位的定点加法

设x=l5000，y=20000，则浮点运算值为z=x+y=35000，显然z>32767，因此

Qx=1，Qy=0，Qz=0，则定点加法为：

x=30000；y=20000；

temp=20000<<1=40000；

temp=temp+x=40000+30000=70000；

z=70000L>>1=35000；

因为z的Q值为0，所以定点值z=35000就是浮点值，这里z是一个长整型数。当加法或加法的结果超过16位表示范围时，如果程序员事先能够了解到这种情况，并且需要保持运算精度时，则必须保持32位结果。如果程序中是按照16位数进行运算的，则超过16位实际上就是出现了溢出。如果不采取适当的措施，则数据溢出会导致运算精度的严重恶化。一般的定点DSP芯片都没有溢出保护功能，当溢出保护功能有效时，一旦出现溢出，则累加器ACC的结果为最大的饱和值(上溢为7FFFH，下溢为8001H)，从而达到防止溢出引起精度严重恶化的目的。

2.2乘法运算的C语言定点模拟

设浮点乘法运算的表达式为：

float x，y，z；

z=xy；

假设经过统计后x的定标值为Qx，y的定标值为Qy，乘积z的定标值为Qz，则

z=xy

zq*2-Qx=xq*yq*2-(Qx+Qy)

zq=(xqyq)2Qz-(Qx+Qy)

所以定点表示的乘法为：

int x，y，z；

long temp；

temp=(long)x；

z=(temp*y)>>(Qx+Qy-Qz)；

例1.5定点乘法。

设x=18.4，y=36.8，则浮点运算值为=18.4*36.8=677.12；

根据上节，得Qx=10，Qy=9，Qz=5，所以

x=18841；y=18841；

temp=18841L；

z=(18841L*18841)>>(10+9-5)=354983281L>>14=21666；

因为z的定标值为5，故定点z=21666，即为浮点的z=21666/32=677.08。

2.3除法运算的C语言定点摸拟

设浮点除法运算的表达式为：

float x，y，z；

z=x/y；

假设经过统计后被除数x的定标值为Qx，除数y的定标值为Qy，商z的定标值为Qz，则

z=x/y

zq*2-Qz=(xq*2-Qx)/(yq*2-Qy)

zq=(xq*2(Qz-Qx+Qy))/yq

所以定点表示的除法为：

int x，y，z；

long temp；

temp=(long)x；

z=(temp<<(Qz-Qx+Qy))/y；

例1.6定点除法。

设x=18.4，y=36.8，浮点运算值为z=x/y=18.4/36.8=0.5；

根据上节，得Qx=10，Qy=9，Qz=15；所以有

z=18841，y=18841；

temp=(long)18841；

z=(18841L<<(15-10+9)/18841=3O8690944L/18841=16384；

因为商z的定标值为15，所以定点z=16384，即为浮点z=16384/215=0.5。

2.4程序变量的Q值确定

在前面几节介绍的例子中，由于x，y，z的值都是已知的，因此从浮点变为定点时Q值很好确定。在实际的DSP应用中，程序中参与运算的都是变量，那么如何确定浮点程序中变量的Q值呢？从前面的分析可以知道，确定变量的Q值实际上就是确定变量的动态范围，动态范围确定了，则Q值也就确定了。

设变量的绝对值的最大值为|max|，注意|max|必须小于或等于32767。取一个整数n，使满足

2n-1<|max|<2n

则有

2-Q=2-15*2n=2-(15-n)

Q=15-n

例如，某变量的值在-1至+1之间，即|max|<1，因此n=0，Q=15-n=15。

既然确定了变量的|max|就可以确定其Q值，那么变量的|max|又是如何确定的呢？一般来说，确定变量的|max|有两种方法。一种是理论分析法，另一种是统计分析法。

1. 理论分析法

有些变量的动态范围通过理论分析是可以确定的。例如：

(1)三角函数。y=sin(x)或y=cos(x)，由三角函数知识可知，|y|<=1。

(2)汉明窗。y(n)=0.54一0.46cos[nπn/(N-1)]，0<=n<=N-1。因为-1<=cos[2πn/(N-1)]<=1，所以0.08<=y(n)<=1.0。

(3)FIR卷积。y(n)=∑h(k)x(n-k)，设∑|h(k)|=1.0，且x(n)是模拟信号12位量化值，即有|x(n)|<=211，则|y(n)|<=211。

(4)理论已经证明，在自相关线性预测编码(LPC)的程序设计中，反射系数ki满足下列不等式：|ki|<1.0，i=1，2，...，p，p为LPC的阶数。

2. 统计分析法

对于理论上无法确定范围的变量，一般采用统计分析的方法来确定其动态范围。所谓统计分析，就是用足够多的输入信号样值来确定程序中变量的动态范围，这里输入信号一方面要有一定的数量，另一方面必须尽可能地涉及各种情况。例如，在语音信号分析中，统计分析时就必须来集足够多的语音信号样值，并且在所采集的语音样值中，应尽可能地包含各种情况。如音量的大小，声音的种类(男声、女声等)。只有这样，统计出来的结果才能具有典型性。

当然，统计分析毕竟不可能涉及所有可能发生的情况，因此，对统计得出的结果在程序设计时可采取一些保护措施，如适当牺牲一些精度，Q值取比统计值稍大些，使用DSP芯片提供的溢出保护功能等。

2.5浮点至定点变换的C程序举例

本节我们通过一个例子来说明C程序从浮点变换至定点的方法。这是一个对语音信号(0.3~3.4kHz)进行低通滤波的C语言程序，低通滤波的截止频率为800Hz，滤波器采用19点的有限冲击响应FIR滤波。语音信号的采样频率为8kHz，每个语音样值按16位整型数存放在insp.dat文件中。

例1.7语音信号800Hz 19点FIR低通滤波C语言浮点程序。

＃i nclude

const int length=180/*语音帧长为180点=22.5ms＠8kHz采样*/

void filter(int xin[]，int xout[]，int n，float h[])；/*滤波子程序说明*/

/*19点滤波器系数*/

static float h[19]=

{0.01218354，-0.009012882，-0.02881839，-0.04743239，-0.04584568，

-0.008692503，0.06446265，0.1544655，0.2289794，0.257883，

0.2289794，0.1544655，0.06446265，-0.008692503，-0.04584568，

-0.04743239，-0.02881839，-0.009012882，O.01218354}；

static int xl[length+20]；

/*低通滤波浮点子程序*/

void filter(int xin[]，int xout[]，int n，float h[])

{

int i，j；

float sum；

for(i=0；i for(i=0；i＜length；i++)

{

sum=0.0；

for(j=0；j＜n；j++)sum+=h[j]*x1[i-j+n-1]；

xout=(int)sum；

for(i=0；i＜(n-l)；i++)x1[n-i-2]=xin[length-1-i]；

}

/*主程序*/

void main()

FILE *fp1，*fp2；

int frame，indata[length]，outdata[length]；

fp1=fopen(insp.dat，"rb")；/* 输入语音文件*/

fp2=fopen(Outsp.dat，"wb")；/* 滤波后语音文件*/

frame=0；

while(feof(fp1) ==0)

{

frame++；

printf(“frame=％d＼n”，frame)；

for(i=0；i＜length；i++)indata=getw(fp1)； /*取一帧语音数据*/

filter(indata，outdata，19，h)；/*调用低通滤波子程序*/

for(i=0；i＜length；i++)putw(outdata，fp2)；/*将滤波后的样值写入文件*/

}

fcloseall()；/*关闭文件*/

return(0)；

}

例1.8语音信号800Hz l9点FIR低通滤波C语言定点程序。

＃i nclude

const int length=180；

void filter (int xin[]，int xout[]，int n，int h[])；

static int h[19]={399，-296，-945，-1555，-1503，-285，2112，5061，7503，8450，

7503，5061，2112，-285，-1503，-1555，-945，-296，399}；/*Q15*/

static int x1[length+20]；

/*低通滤波定点子程序*/

void filter(int xin[]，int xout[]，int n，int h[])

int i，j；

long sum；

for(i=0；i＜length；i++)x1[n＋i-111=xin]；

for(i=0；i＜1ength；i++)

sum=0；

for(j=0；j＜n；j++)sum+=(long)h[j]*x1[i-j＋n-1]；

xout=sum>>15；

for(i=0；i＜(n-1)；i＋＋)x1[n-i-2]=xin[length-i-1]；

}

主程序与浮点的完全一样。“

3 DSP定点算术运算

定点DSP芯片的数值表示基于2的补码表示形式。每个16位数用l个符号位、i个整数位和15-i个小数位来表示。因此：

00000010.10100000

表示的值为：

21＋2-1＋2-3=2.625

这个数可用Q8格式(8个小数位)来表示，其表示的数值范围为-128至＋l27.996，一个Q8定点数的小数精度为1/256=0.004。

虽然特殊情况(如动态范围和精度要求)必须使用混合表示法。但是，更通常的是全部以Q15格式表示的小数或以Q0格式表示的整数来工作。这一点对于主要是乘法和累加的信号处理算法特别现实，小数乘以小数得小数，整数乘以整数得整数。当然，乘积累加时可能会出现溢出现象，在这种情况下，程序员应当了解数学里面的物理过程以注意可能的溢出情况。下面我们来讨论乘法、加法和除法的DSP定点运算，汇编程序以TMS320C25为例。

3.1定点乘法

两个定点数相乘时可以分为下列三种情况：

1. 小数乘小数

例1.9 Q15*Q15=Q30

0.5*0.5=0.25

0.100000000000000；Q15

* 0.100000000000000；Q15

--------------------------------------------

00.010000000000000000000000000000=0.25；Q30

两个Q15的小数相乘后得到一个Q30的小数，即有两个符号位。一般情况下相乘后得到的满精度数不必全部保留，而只需保留16位单精度数。由于相乘后得到的高16位不满15位的小数据度，为了达到15位精度，可将乘积左移一位，下面是上述乘法的TMS320C25程序：

LT OP1；OP1=4000H(0.5/Q15)

MPY OP2；oP2=4000H(0.5/Ql5)

PAC

SACH ANS，1；ANS=2000H(0.25/Q15)
