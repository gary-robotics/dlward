---
layout:     post
title:      "AndroidDriver"
subtitle:   "android"
date:       2018-07-19 12:00:00
author:     "Edlward"
header-img: "img/post-bg-2015.jpg"
header-mask: 0.3
catalog:    true
tags:
    - android
---
# 路线
[如何选择单片机和Android-LInux-ARM开发板？](https://www.zhihu.com/question/41812528)  
[嵌入式开发职业课程](http://www.makeru.com.cn/roadmap/emb)   
[LTE](https://cn0xroot.com/2018/06/15/sdr-developer-guild-part-1/)   


# OPENCV 
[OpenCV移植到ARM全过程-III](https://blog.csdn.net/kaychangeek/article/details/78552418)  
[tiny4412移植opencv2.4.7手记](https://blog.csdn.net/u010606097/article/details/41316271)    
[OpenCV结合V4l2实现人脸检测](https://blog.csdn.net/wr132/article/details/54564044)  
[V4l编程以及Qt相关应用](https://blog.csdn.net/wr132/article/details/54348465)  

# Camera
[S5PV210 camera 驱动分析（android）](https://blog.csdn.net/liuying_0408/article/details/7532470)  

# Android Driver  
[ARM Tiny210v2开发板Android系统读写串口设备](https://blog.csdn.net/chenxupro/article/details/12249641)  
[FriendlyARM Tiny210v2 SPI接口Android平台测试](https://blog.csdn.net/chenxupro/article/details/8746544)  
[哇咔咔！用Android手机控制电脑](https://blog.csdn.net/chenxupro/article/details/7225530)  
[和菜鸟一起学android4.0.3源码之wifi的简单分析](https://blog.csdn.net/andrinux/article/details/38418243)  
[Android驱动（一）硬件访问服务学习之（一）Android通过JNI访问硬件](https://blog.csdn.net/fengyuwuzu0519/article/details/55224423)  
[Android驱动（一）硬件访问服务学习之（一）Android通过JNI访问硬件](https://blog.csdn.net/fengyuwuzu0519/article/details/55224423)  



## LINUX QT  
[Android应用程序通过JNI调用驱动程序(友善Smart210)](https://blog.csdn.net/xie0812/article/details/19628109)  
[Android 源码编译及常见错误及解决方法](https://www.cnblogs.com/kyyblabla/p/3603931.html)  
[Ubuntu12.04 制作Smart210的编译环境](https://blog.csdn.net/kanchuan1905/article/details/51239702)  
[Smart210一键部署运行qt程序](https://blog.csdn.net/westlor/article/details/50481109)     
[Qt-5.3.2 在友善Smart210开发板的移植记录](https://blog.csdn.net/newthinker_wei/article/details/39560109)  
[车载实时路况信息接收终端移植于Smart210开发板 --- 综合教程](https://blog.csdn.net/geng823/article/details/31898369)    
[Qt移植以及QT creator一键调试](https://blog.csdn.net/kunkliu/article/details/78740933)   
[关于友善之臂Tiny210电容屏移植tslib](https://blog.csdn.net/embed_coder/article/details/52156427)  
[移植 Qt 至 tiny210 详细过程](http://www.cnblogs.com/GyForever1004/p/8955665.html)  
[tiny210 tslib 测试（基于 ft5x06 触摸屏），解决触摸无效问题](https://www.cnblogs.com/GyForever1004/p/8955673.html)

## LINUX 根文件系统    


## Linux Driver
[linux的串口驱动分析](https://www.cnblogs.com/chd-zhangbo/p/5410336.html)    
[/etc/init.d/rcS内容分析](https://blog.csdn.net/bailyzheng/article/details/7487359)  
[qemu搭建kernel学习环境](https://blog.csdn.net/kevin_mr/article/details/52754757)    
[OK210-uvc摄像头采集并显示在屏幕上（v4l2编程）](https://blog.csdn.net/kevin_mr/article/details/51470215)  
[Linux 下V4l2摄像头采集图片，实现yuyv转RGB,RGB转BMP，RGB伸缩，jpeglib 库实现压缩RGB到内存中，JPEG经UDP发送功](https://blog.csdn.net/xuyangwyw/article/details/40476653)  
[设备模型(device-model)之平台总线（bus），驱动（driver），设备（device）](http://www.cnblogs.com/hackfun/p/5951235.html)  
[基于Linux3.0.8+smart210的DS18B20驱动移植](https://blog.csdn.net/gz_go/article/details/45952879)  
[Smart210学习-----lcd驱动](https://www.cnblogs.com/qigaohua/p/5469192.html)  
[移植tiny210的 触摸屏驱动](https://blog.csdn.net/u014600130/article/details/35268873)  


## LINUX 项目   
[基于S5pv210流媒体服务器的实现之网络摄像头](https://blog.csdn.net/liukun321/article/details/24390379)  
[串口编程](https://wenku.baidu.com/view/152473048e9951e79b8927cc.html)  
[ARM（s5pv210）采用V4L2采集USB摄像头图像，送入OPENCV做图像识别，然后经过h264硬件编码后经过ORTP编码通过wifi传输到PC端，在vlc媒体播放器实时播放视频-ARM（s5pv210）使用V4L2 USB相机图像捕获，图像识别](http://www.codeforge.cn/article/303362/)   
[远程视频监控之应用篇（mjpg-streamer）](https://www.cnblogs.com/wanghuaijun/p/8098460.html)  


## Debug  
[Linux下CodeBlocks远程调试ARM程序环境搭建](https://blog.csdn.net/wcl719236538/article/details/52314231)  

## GHOTO
[windows+Ubuntu双系统引导修复（终极版）](https://blog.csdn.net/lhj_168/article/details/75212421)  
[Tiny210移植mjpeg-streamer](https://www.linuxidc.com/Linux/2015-05/116962.htm)  
[你必须安装libtool和autopoint：](https://sourceforge.net/p/gphoto/mailman/message/11167978/)  

sudo apt-get install autoreconf  
sudo apt-get update  
sudo apt-get install libtool autopoint  
sudo apt-get install libpopt-dev  
autoreconf -is  
./configure
make   
make install  


如果你不能只用你的安装libpopt-dev或popt-devel包
系统的标准包机制，手动安装到一些前缀
然后设置

   POPT_CFLAGS = 3D-I $ {PREFIX} /包括
   POPT_LIBS = 3D“-L $ {prefix} / lib -lpopt”

在运行gphoto2的配置之前。

但是，只需从您的安装适当的popt开发包
分配是推荐的方式。
[缺少libltdl的交叉编译代码](https://forum.archive.openwrt.org/viewtopic.php?id=56184&p=1)  
[linux下USB数据包分析(usbmon + wireshark)](http://www.lnsign.com/2018/03/06/usb-packet-capture-usbmon-wireshark/)  

## 摄像头
[USB摄像头(V4L2接口)的图片采集](https://www.cnblogs.com/surpassal/archive/2012/12/19/zed_webcam_lab1.html)  
[嵌入式Linux驱动笔记(十八)------浅析V4L2框架之ioctl](https://blog.csdn.net/guet_kite/article/details/78574781) 
[详解V4L2框架(UVC驱动)](https://blog.csdn.net/Guet_Kite/article/details/78570059)  

## I2C

Linux I2C相对来说稍微复杂了些，当时听课时，理解了大半，后来因为没有及时复习，导致渐渐遗忘。

现在重新拾起，写一份详细的笔记，以备后期复习，也供大家学习之用。
I2C我就不解释了。有兴趣看笔记的自然也知道什么是I2C。
先来个实用的，说说一般我们是怎么利用I2C框架操作I2C驱动设备的。
如果我们需要在产品中增加一个保存一些少量数据的功能，那么可以在硬件上增加一个E2prom(at24c08)芯片，
该芯片是用I2C协议通信的，我们就以这个例子来说说。
设备、资源准备(完成I2C硬件设备的添加):
       1、首先将24c08焊接到S5PV210的I2C0控制器引脚上，调整其A0\A1\A2引脚的高低电平 来设置其器件地址(0xA0)。
       2、将24c08的器件地址以及设备名加入到 __i2c_board_list 链表
              1、在Mach-smdkv210.c文件中的 i2c_board_info smdkv210_i2c_devs0 增加：
              static struct i2c_board_info smdkv210_i2c_devs0[] __initdata = {
                            ...
                            { I2C_BOARD_INFO("24c08", 0x50), },     /* Samsung S524AD0XD1 */
                            ...
                            ...
                     };
       (注意，这里的24c08的真实器件地址是0xA0,因为还有个读写位，所以需要将0xA0右移动一位 0xA0>>1 = 0x50 )
在使用I2C子系统的时候，需要将 i2c-dev.c  i2c-core.c  i2c-s3c2410.c 编译进内核( make zImage/uImage)      
1、首先看源码所在目录下的Makefile    ~/linux_source/linux-3.0.8/drivers/i2c/Makefile
1、i2c-dev.c 驱动层  i2c-core.c 核心层


2、i2c-s3c2410.c 总线 ~/linux_source/linux-3.0.8/drivers/i2c/busses/Makefile


2、针对Makefile中的 CONFIG_I2C->I2C、CONFIG_I2C_SMBUS 在Kconfig中寻找




3、在Kconfig中找到 I2C_support、I2C_device interface，然后配置内核 make menuconfig
主界面 ---> Device Drivers  --->  <*> I2C_support --->  <*> I2C_device_interface





应用层利用Linux I2C框架来读写I2C设备有两种方式(大概流程-后面会有详细实现代码)：
       1、利用I2C适配器设备文件的方式(需要指定I2C设备的器件地址)
              直接可以编写应用层代码即可。
              步骤：(以E2prom为例子，它挂在第0个I2C控制器)
                     1、打开I2C设备I2C控制器0
                            fd = open("/dev/i2c-0", O_RDWR);
                     2、发送E2prom的I2C器件地址 addr = 0x50
                            ioctl(fd, I2C_SLAVE, addr)
                     3、读数据 需要先写入要读取的起始地址(E2prom里的地址)
                            write(fd, &chip_addr, 1);
                            read(fd, rbuf, 8);
                     4、写数据 需要先写入要写入的起始地址(E2prom里的地址)
                            wbuf[0] = 0x0;       // 指定要从 0 地址开始写
                            strncpy(tmp+1, data, strlen(data));
                            write(fd, wbuf, 9);
                     5、关闭
                            close(fd);         
       2、自己写驱动，为指定I2C设备创建一个设备文件供应用层直接打开操作(只需要提供设备名即可)
              需要自己写一个ko驱动，然后应用层打开由这个ko文件创建的设备文件，进行操作
              步骤：(以E2prom为例子，它的设备名为 24c08)
                     1、编写ko驱动流程
                            1、构建struct i2c_driver，实现 .probe       .remove       成员
                            2、实现.probe()、.remove() 函数
                                   1、获取Client
                                   2、申请设备号、关联操作方法(即 fops)
                                   3、创建设备类、设备节点文件(如 e2prom) 供上层操作
                                   4、实现fops各函数，如read、write 等。。。
                            3、i2c_add_driver(&e2prom_drv);
                                   当注册I2C驱动后，i2c核心层会将此驱动的id_table与设备链表中的I2C_Client的
                                   名字进行匹配,匹配成功后会执行.probe()函数
                     2、编写上层应用
                            fd =open("/dev/e2prom",O_RDWR);
                            读写方式与上面一样，只是不需要再利用ioctl发送器件地址。
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
好了，用是知道怎么用，那么实现原理是什么呢。这里涉及到平台驱动的知识，因为I2C需要通过平台驱动来初始化I2C控制器，
不懂的童鞋请先搞懂平台驱动。
首先要了解I2C驱动的工作的大致流程，抓住这个大致流程后，再具体分析代码时就会轻松很多：
第一步，就是我们准备的资源了：
       1、所有I2C设备的板级信息，如E2prom的设备名和器件地址
~/linux_source/linux-3.0.8/arch/arm/mach-s5pv210/mach-smdkv210.c
static struct i2c_board_info smdkv210_i2c_devs0[] __initdata = {
       { I2C_BOARD_INFO("24c08", 0x50), },     /* Samsung S524AD0XD1 */
       { I2C_BOARD_INFO("wm8580", 0x1b), },
};
static struct i2c_board_info smdkv210_i2c_devs1[] __initdata = {};
static struct i2c_board_info smdkv210_i2c_devs2[] __initdata = {};
(这里的I2C设备资源会在mach-smdkv210.c 里面被加入了 __i2c_board_list 链表)
       2、每个I2C控制器的平台设备资源，主要是控制器的硬件资源(如相关寄存器、中断)(S5PV210 平台有三个I2C控制器)
~/linux_source/linux-3.0.8/arch/arm/plat-samsung/dev-i2c0.c -> struct platform_device s3c_device_i2c0 = {}
static struct resource s3c_i2c_resource[] = {
        [0] = {
                .start  = S3C_PA_IIC,
                .end        = S3C_PA_IIC + SZ_4K - 1,
                .flags        = IORESOURCE_MEM,                                // 内存资源 即寄存器地址
        },
        [1] = {
                .start        = IRQ_IIC,
                .end        = IRQ_IIC,
                .flags        = IORESOURCE_IRQ,                                // 中断资源
        },
};
struct platform_device s3c_device_i2c0 = {
        .name                        = "s3c2410-i2c",
        .id                                = 0,
        .id                                = -1,
        .num_resources        = ARRAY_SIZE(s3c_i2c_resource),
        .resource                = s3c_i2c_resource,
}
  
~/linux_source/linux-3.0.8/arch/arm/plat-samsung/dev-i2c1.c -> struct platform_device s3c_device_i2c1 = {}
       ......
~/linux_source/linux-3.0.8/arch/arm/plat-samsung/dev-i2c2.c -> struct platform_device s3c_device_i2c2 = {}
       ......

里面指定的名字：s3c2410-i2c是会与平台驱动匹配~/linux_source/linux-3.0.8/drivers/i2c/busses/i2c-s3c2410.c
       3、每个I2C控制器的平台设备的私有数据，这里主要是给每一个I2C控制器编号，用来识别I2C设备挂载在哪个I2C控制器上
~/linux_source/linux-3.0.8/arch/arm/plat-samsung/dev-i2c0.c -> static struct s3c2410_platform_i2c default_i2c_data0 __initdata = {}
~/linux_source/linux-3.0.8/arch/arm/plat-samsung/dev-i2c1.c -> static struct s3c2410_platform_i2c default_i2c_data1 __initdata = {}
~/linux_source/linux-3.0.8/arch/arm/plat-samsung/dev-i2c2.c -> static struct s3c2410_platform_i2c default_i2c_data2 __initdata = {}
(I2C的平台设备资源和平台私有数据也会在 mach-smdkv210.c 被加载)
第二步，就是内核启动后，I2C框架流程(第二步很重要，系统开机时完成的)：
       1、内核会先将所有的I2C设备的板级资源加载到 __i2c_board_list 链表(包含该I2C设备挂载在I2C控制器的编号，我们手动指定的)
~/linux_source/linux-3.0.8/arch/arm/mach-s5pv210/mach-smdkv210.c
i2c_register_board_info(0, smdkv210_i2c_devs0, ARRAY_SIZE(smdkv210_i2c_devs0));
i2c_register_board_info(1, smdkv210_i2c_devs1, ARRAY_SIZE(smdkv210_i2c_devs1));
i2c_register_board_info(2, smdkv210_i2c_devs2, ARRAY_SIZE(smdkv210_i2c_devs2));
int __init i2c_register_board_info(int busnum, struct i2c_board_info const *info, unsigned len)
{
int status;
down_write(&__i2c_board_lock);
/* dynamic bus numbers will be assigned after the last static one */
if (busnum >= __i2c_first_dynamic_bus_num)
__i2c_first_dynamic_bus_num = busnum + 1;
// for 循环将I2C 设备加入__i2c_board_list 链表
for (status = 0; len; len--, info++) {
struct i2c_devinfo*devinfo;
devinfo = kzalloc(sizeof(*devinfo), GFP_KERNEL);
if (!devinfo) {
pr_debug("i2c-core: can't register boardinfo!\n");
status = -ENOMEM;
break;
}
devinfo->busnum = busnum; //I2C设备所在I2C控制器编号
devinfo->board_info = *info;
// 加入__i2c_board_list 链表
list_add_tail(&devinfo->list, &__i2c_board_list);
}
up_write(&__i2c_board_lock);
return status;
}


       2、然后设置平台私有数据和加载所有I2C控制器的平台设备资源，S5PV210只有三个I2C控制器，所以只加载了三次
~/linux_source/linux-3.0.8/arch/arm/mach-s5pv210/mach-smdkv210.c
/* 设置平台私有数据 */
       s3c_i2c0_set_platdata(NULL);
       s3c_i2c1_set_platdata(NULL);
       s3c_i2c2_set_platdata(NULL);
        void __init s3c_i2c0_set_platdata(struct s3c2410_platform_i2c *pd)
        {
        struct s3c2410_platform_i2c *npd;
        if (!pd)
        pd = &default_i2c_data0; //这里是私有数据，里面有编号
        // 分配空间并将pd 数据拷入
        npd = kmemdup(pd, sizeof(struct s3c2410_platform_i2c), GFP_KERNEL);
        if (!npd)
        printk(KERN_ERR "%s: no memory for platform data\n", __func__);
       else if (!npd->cfg_gpio)
        npd->cfg_gpio = s3c_i2c0_cfg_gpio;
        // 将平台设备的私有数据指针指向该空间
        s3c_device_i2c0.dev.platform_data = npd;
           } 
                static struct s3c2410_platform_i2c default_i2c_data0 __initdata = {
        .flags= 0,
                        .bus_num        = 0,                        //I2C控制器编号
        .slave_addr= 0x10,
        .frequency= 100*1000,
        .sda_delay= 100,
        };
/* 加载平台设备资源 */
static struct resource s3c_i2c_resource[] = {
[0] = {
.start = S3C_PA_IIC,
.end   = S3C_PA_IIC + SZ_4K - 1,
.flags = IORESOURCE_MEM,// 内存资源
},
[1] = {
.start = IRQ_IIC,
.end   = IRQ_IIC,
.flags = IORESOURCE_IRQ,// 中断资源
},
};
struct platform_device s3c_device_i2c0 = {// I2C 控制器0
.name  = "s3c2410-i2c",            // 是与平台驱动匹配的依据
#ifdef CONFIG_S3C_DEV_I2C1
.id  = 0,
#else
.id  = -1,
#endif
.num_resources  = ARRAY_SIZE(s3c_i2c_resource),
.resource  = s3c_i2c_resource,// 指向该资源
};
static struct s3c2410_platform_i2c default_i2c_data0 __initdata = {
.flags= 0,
.slave_addr= 0x10,
.frequency= 100*1000,
.sda_delay= 100,
};
static struct platform_device *smdkv210_devices[] __initdata = {
...
       &s3c_device_i2c0,
       &s3c_device_i2c1,
       &s3c_device_i2c2,
...
};
platform_add_devices(smdkv210_devices, ARRAY_SIZE(smdkv210_devices));
I2C平台设备资源里面的s3c_device_i2c*.name 会和 I2C平台驱动里面的 s3c24xx_i2c_driver.id_table匹配
s3c_device_i2c*.name = “s3c2410-i2c”  s3c24xx_i2c_driver.id_table = s3c24xx_driver_ids
static struct platform_device_id s3c24xx_driver_ids[] = {
       {
              .name              = "s3c2410-i2c",                            // 完全匹配 和  s3c_device_i2c*.name  一致
              .driver_data       = TYPE_S3C2410,
       }, {
              .name              = "s3c2440-i2c",
              .driver_data       = TYPE_S3C2440,
       }, { },
};
       3、因为平台设备的加载关系，名字匹配成功后，系统回调了(i2c-s3c2410.c)的probe()函数
在(i2c-s3c2410.c)入口函数中已经注册了平台设备驱动，所以会调用里面的probe()函数
~/linux_source/linux-3.0.8/drivers/i2c/busses/i2c-s3c2410.c
static int __init i2c_adap_s3c_init(void)
{
       return platform_driver_register(&s3c24xx_i2c_driver);
}
       4、probe()函数的主要工作：(S5PV210 平台有三个I2C控制器，所以这里会被调用3次，会产生3个i2c_adap)
~/linux_source/linux-3.0.8/drivers/i2c/busses/i2c-s3c2410.c
              1、从平台设备中获取私有数据，即该I2C控制器的编号
pdata = pdev->dev.platform_data;
              2、为I2C控制器构建i2c_adapter，设置方法(master_xfex) 即与I2C设备通信的方法(I2C协议通信的实现)
strlcpy(i2c->adap.name, "s3c2410-i2c", sizeof(i2c->adap.name));
i2c->adap.owner   = THIS_MODULE;
i2c->adap.algo    = &s3c24xx_i2c_algorithm;
i2c->adap.retries = 2;
i2c->adap.class   = I2C_CLASS_HWMON | I2C_CLASS_SPD
              3、获取I2C时钟，并使能I2C时钟源
i2c->clk = clk_get(&pdev->dev, "i2c");
              4、获取I2C平台设备资源(该I2C控制器的寄存器)
platform_get_resource(pdev, IORESOURCE_MEM, 0);
              5、将寄存器地址 内存映射出来
i2c->regs = ioremap(res->start, resource_size(res));
              6、初始化该I2C控制器，如管脚功能配置、设置时钟、初始化等
s3c24xx_i2c_init(i2c);
              7、获取I2C平台设备中断资源并注册中断
i2c->irq = ret = platform_get_irq(pdev, 0);
request_irq(i2c->irq, s3c24xx_i2c_irq, IRQF_DISABLED, dev_name(&pdev->dev), i2c);
8、将从平台私有数据获取到的 编号 赋值给 adap
i2c->adap.nr = pdata->bus_num;
              9、将i2c_adapter 加入到I2C设备链表
i2c_add_numbered_adapter(&i2c->adap);
adap->dev.bus = &i2c_bus_type;
adap->dev.type = &i2c_adapter_type;              
device_register(&adap->dev);                     // 将i2c_adapter 加入设备链表
              10、从__i2c_board_list取出I2C设备所包含的编号与该I2C控制器的编号匹配 (有三个I2C设备就会找到三次)
                     匹配成功后将该I2C设备构建一个I2C_client，并将板级信息填充进去(设备名和器件地址)并把I2C_adapter记录其中。
list_for_each_entry(devinfo, &__i2c_board_list, list)
{
       if (devinfo->busnum == adapter->nr && !i2c_new_device(adapter, &devinfo->board_info))
              dev_err(&adapter->dev,"Can't create device at 0x%02x\n", devinfo->board_info.addr);
}
i2c_new_device(adapter, &devinfo->board_info)
       client = kzalloc(sizeof *client, GFP_KERNEL);
       client->adapter = adap;                                                        // I2C控制器
       client->dev.platform_data = info->platform_data;
       client->flags = info->flags;
       client->addr = info->addr;                                                        // 器件地址
       client->irq = info->irq;
strlcpy(client->name, info->type, sizeof(client->name));              // 设备名
       client->dev.parent = &client->adapter->dev;
       client->dev.bus = &i2c_bus_type;
       client->dev.type = &i2c_client_type;
       client->dev.of_node = info->of_node;
dev_set_name(&client->dev, "%d-%04x", i2c_adapter_id(adap), client->addr);
              11、将I2C_Client 加入到I2C设备链表              
device_register(&client->dev);                                   // client 加入设备链表

              由probe()的流程来看，它主要的工作是初始化I2C控制器，构建I2C_adapter和I2C_Client，并将其加入到I2C设备链表。
              I2设备链表中有I2C_adapter和I2C_Client，I2C_adapter数量取决于I2C控制器的数量，而I2C_Client的数量取决于I2C设备的数量。
        

              I2C_adapter与I2C_Client的关系：
                     I2C_adapter指的是某个I2C控制器，包含有I2C通信的方法，即产生标准I2C的时序与I2C设备通信
                     I2C_Client 指的是某个I2C设备，包含有设备名和器件地址以及所挂接在的哪个I2C控制器中，即I2C_adapter

              struct i2c_adatper                                   //表示i2c适配器/i2c控制器
              {
                     struct i2c_algorithm *algo;              // 通信方法 重要 操作硬件 I2C协议的实现
struct device dev;                            // 设备对象
int nr;                                          // 适配器编号 用来匹配 I2C_Clinet和作为设备号
char name[48];                            // 适配器名字
                     ...
              };

              struct i2c_client                                   //表示一个i2c设备
              {
                     unsigned short addr;                     //设备地址
                     char name[I2C_NAME_SIZE];       //设备名字
                     struct device dev;                            //设备结构体
                     struct i2c_adapter *adapter;       //所属适配器
                     int irq;                                          //此设备对应的中断号
              };

第三步，i2c-dev.c 的流程：
1、注册名为”i2c”的字符设备文件和”i2c-dev”的类，并且绑定fops
res = register_chrdev(I2C_MAJOR, "i2c", &i2cdev_fops);
2、遍历所有的I2C_adapter
i2c_for_each_dev(NULL, i2cdev_attach_adapter);
3、每找到一个I2C_adapter 就会以“i2c-编号”创建设备节点
i2c_dev->dev = device_create(i2c_dev_class, &adap->dev, MKDEV(I2C_MAJOR, adap->nr), NULL, "i2c-%d", adap->nr);
4、当上层 调用open("/dev/i2c-0"); --> static int i2cdev_open(...)
       1、设备号中获取到i2c_adapter
            2、构建一个client，并将i2c_adapter 保存在client
       3、将client保存到file私有数据
5、当上层调用ioctl()时 --> static long i2cdev_ioctl(...)
   1、从file私有数据取出由i2c_client
   2、根据cmd、 arg设置i2c_client 相关标志
6、当上层调用read()时 -->static ssize_t i2cdev_read(...)
       1、从file私有数据取出i2c_client
       2、调用 i2c_master_recv(client, tmp, count); 从I2C设备读取数据
   3、将读出的数据 copy_to_user(buf, tmp, count) 拷贝到用户空间
7、当上层调用write()时 -->static ssize_t i2cdev_write(...)
       1、从file私有数据取出i2c_client
   2、调用tmp = memdup_user(buf, count); 将数据拷贝到内核空间
       3、调用 i2c_master_send(client, tmp, count); 将数据发送出去
8、当上层调用close()时 --> static int i2cdev_release(...)
       1、从file私有数据取出i2c_client
  struct i2c_client *client = file->private_data;
       2、释放client kfree(client);
   3、设置file私有数据为空 file->private_data = NULL; 
第四步，现在I2C_adapter与I2C_Client都已经准备好，准备这些有什么用呢?
       回想此笔记一开始介绍的两种利用Linux I2C框架来读写I2C设备的方式。
       第一种：利用I2C适配器设备文件的方式，利用I2C_adapter来与I2C设备通信（利用I2C-dev.c）。
                     因为I2C_adapter只有通信方法，并没有器件地址，所以需要利用ioctl将器件地址发给它。
                     在open时底层会临时构建一个的I2C_Client，里面会保存我们发给的器件地址，以及当前的I2C_adapter。
                     通过 i2c_master_send(client, data, size); 将数据发出去.
                     通过 i2c_master_recv(client, tmp, count); 将数据读出来.
在close是会释放I2C_Client              
       第二种：利用自己写驱动，为指定I2C设备创建一个设备文件供应用层直接打开操作的方式(绕过I2C-dev.c)。
                     1、当注册I2C驱动时，i2c核心层会将此驱动加入I2C驱动链表
driver->driver.bus = &i2c_bus_type;      
driver_register(&driver->driver);       ----> 注意，和I2C_adapter\I2C_Client注册函数不一样
2、并将此驱动的id_table与设备链表中的I2C_Client的名字进行匹配.(即会调用 (i2c-core.c)i2c_device_match())
                     3、匹配成功后会执行我们驱动实现的probe()函数 并且把匹配成的I2C_Client 传进去
i2c_for_each_dev(driver, __process_new_driver);
4、probe()函数获取到I2C_Client，该I2C_Client里已经包含有器件地址，同时也包含了其所属的I2C_adapter，
                           所以我们可以通过 i2c_master_send(client, data, size); 将数据发出去.
                        通过 i2c_master_recv(client, tmp, count); 将数据读出来.
                     因此，我们自己写的驱动是不需要指定器件地址的。
       从上述可见，要读写I2C设备，必须知道该I2C设备是挂接在哪个I2C控制器，以及它的器件地址。
第五步，分析I2C框架的数据传递机制（表面）。
              i2c_master_send()、i2c_master_recv() 会构建一个struct i2c_msg msg 数据包，然后调用i2c_transfer()。
              struct i2c_msg                                          //表示一个i2c数据包
              {
                     __u16 addr;                                          //设备地址,指定此数据包是传送给哪个设备的
                     __u16 flags;                                          //表示此数据包是读包还是写,0-表示写 1-表示读
                     __u16 len;                                          //有效数据长度
                     __u8 *buf;                                          //有效数据指针
              };
              msg.addr = client->addr;
              msg.flags = client->flags & I2C_M_TEN;
              msg.len = count;
              msg.buf = (char *)buf;
              ret = i2c_transfer(client->adap, &msg, 1);  
---> adap->algo->master_xfer(adap, msgs, num);   
              他们最终都是调用了I2C_adapter里的产生时序的方法，从而进行数据交互。
---------------------------------------------------------------------------------------------
利用i2c_dev.c 通用驱动方式 代码：
---------------------------------------------------------------------------------------------
#include<stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#define I2C_SLAVE0x0703
/*./led_test /dev/i2c-x w
*./led_test /dev/i2c-x r
*/
int main(int argc,char **argv)
{
int fd;
int i;
int addr = 0x50; /* The I2C address 器件地址*/
char chip_addr =0x0;
char *data ="lovemengx";
char wbuf[512];
char rbuf[512];
if ((fd = open(argv[1],O_RDWR)) < 0)
{
perror("open failed");
exit(1);
}
/*发器件地址*/
if (ioctl(fd,I2C_SLAVE,addr) < 0)
{
perror("ioctl failed");
exit(1);
}
/*写数据*/
if(strcmp(argv[2],"w")==0)
{
// 将要写入的地址放入数组
wbuf[0] = chip_addr;
char *tmp;
tmp =&wbuf[1];
// 将要写入的数据追加到数组
strncpy(tmp,data,strlen(data));
for(i=1;i<=8;i++)
printf("%d,wbuf[ i]=%c\n",i,wbuf[ i]);
// 写入数据
if (write(fd,wbuf,9) != 9)
{
perror("write failed");
exit(1);
}
}
else /*读数据*/
{
// 先写入要读取的地址
if(write(fd,&chip_addr,1)!=1)
{
perror("write failed");
exit(1);
}
// 从该地址起读取数据
if(read(fd,rbuf,8)!=8)
{
perror("read failed");
exit(1);
}
for(i=0;i<8;i++)
printf("rbuf[ i]=%d\n",rbuf[ i]);
}
close(fd);
return 0;
}

------------------------------------------------------------------------------------------
自己写驱动的方式   驱动层
------------------------------------------------------------------------------------------
/*e2prom_drv
  *参照:i2c_dev.c
  */
#include<linux/init.h>
#include<linux/module.h>
#include<linux/fs.h>
#include<linux/device.h>
#include<linux/i2c.h>
#include<linux/slab.h>
#include<asm/uaccess.h>
int e2prom_probe(struct i2c_client*client, const struct i2c_device_id *id);
int e2prom_remove(struct i2c_client *client);
#define AT24C02_MAJOR250
struct e2prom_device{
struct i2c_client *at24c02_client;
struct device *at24c02_device;
struct class *at24c02_class;
};
struct e2prom_device *at24c02_dev;
int at24c02_open(struct inode *inode, struct file *file)
{
return 0;
}
/*./i2c_test_simple r*/
static ssize_t at24c02_read(struct file *file, char __user *buf, size_t size, loff_t *opps)
{
int ret;
char *tmp;
tmp =kmalloc(size,GFP_KERNEL);
if(tmp ==NULL){
printk("no memory for kmalloc!\n");
return -ENOMEM;
}
/*从核心层获取数据*/
ret =i2c_master_recv(at24c02_dev->at24c02_client,tmp,size);
/*拷贝到用户空间*/
if(ret>0)
ret =(copy_to_user(buf,tmp,size))?-EINVAL:size;
kfree(tmp);
return ret;
}

/*./i2c_test_simple w*/
static ssize_t at24c02_write(struct file *file, const char __user *buf, size_t size, loff_t *opps)
{
int ret;
char *tmp;
tmp =kmalloc(size,GFP_KERNEL);
if(tmp ==NULL){
printk("no memory for kmalloc!\n");
return -ENOMEM;
}
/*获取用户控件的数据*/
ret =copy_from_user(tmp,buf,size);
if(ret){
printk("copy data failed!\n");
kfree(tmp);
return -EFAULT;
}
/*将数据提交给核心层*/
ret=i2c_master_send(at24c02_dev->at24c02_client,tmp,size);
kfree(tmp);
return ret;
}
// fops 结构体
struct file_operations at24c02_fops={
.owner=THIS_MODULE,
.open=at24c02_open,
.write=at24c02_write,
.read=at24c02_read,
};
// 用于匹配 i2c_client
struct i2c_device_id e2prom_id[]={
[0]={
.name="24c02",
.driver_data =0,
},
[1]={
.name="24c04",
.driver_data =0,
},
};

/*3. 构建i2c_driver结构体*/
struct i2c_driver e2prom_drv={
.probe=e2prom_probe,
.remove=e2prom_remove,
.driver={
.name="e2prom",
.owner=THIS_MODULE,
},
.id_table=e2prom_id,
};
/*匹配i2c_client成功之后会调用此函数*/
int e2prom_probe(struct i2c_client*client, const struct i2c_device_id *id)
{
int ret;
at24c02_dev=kmalloc(sizeof(struct e2prom_device *),GFP_KERNEL);
if(at24c02_dev==NULL){
printk("no memory for kmalloc!\n");
return -ENOMEM;
}
/*1. 获取client 保存到全局变量中*/
at24c02_dev->at24c02_client =client;
at24c02_dev->at24c02_client->driver =&e2prom_drv;
/*2. 申请设备号,注册操作方法*/
ret =register_chrdev(AT24C02_MAJOR,"e2prom",&at24c02_fops);
if(ret!=0){
printk("request major failed!\n");
ret =-EIO;
goto err1;
}
/*3. 创建设备文件*/
at24c02_dev->at24c02_class =class_create(THIS_MODULE,"at24c02_class");
if(IS_ERR(at24c02_dev->at24c02_class)){
printk("class create failed!\n");
ret =PTR_ERR(at24c02_dev->at24c02_class);
goto err2;
}
at24c02_dev->at24c02_device=device_create(at24c02_dev->at24c02_class,NULL,MKDEV(AT24C02_MAJOR,0),NULL,"e2prom");
if(IS_ERR(at24c02_dev->at24c02_device)){
printk("class create failed!\n");
ret =PTR_ERR(at24c02_dev->at24c02_device);
goto err3;
}
return 0;
err3:
class_destroy(at24c02_dev->at24c02_class);
err2:
unregister_chrdev(AT24C02_MAJOR,"e2prom");
err1:
kfree(at24c02_dev);
return ret;
}

int e2prom_remove(struct i2c_client *client)
{
device_destroy(at24c02_dev->at24c02_class,MKDEV(AT24C02_MAJOR,0));
class_destroy(at24c02_dev->at24c02_class);
unregister_chrdev(AT24C02_MAJOR,"e2prom");
kfree(at24c02_dev);
return 0;
}

/*1. 实现模块加载函数
  *insmod e2prom_drv.ko
  */
static int __init e2prom_init(void)
{
/*注册i2c驱动*/
i2c_add_driver(&e2prom_drv);
return 0;
}

/*2. 实现模块卸载函数*/
static void __exit e2prom_exit(void)
{
i2c_del_driver(&e2prom_drv);
}
module_init(e2prom_init);
module_exit(e2prom_exit);
MODULE_LICENSE("GPL");
------------------------------------------------------------------------------------------
自己写驱动的方式   应用层
------------------------------------------------------------------------------------------
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#define I2C_SLAVE0x0703
int main(int argc,char **argv)
{
int fd;
int addr =0x50;
char register_addr =0x05;
char wbuf[2];
char rbuf[10];
/*1. 打开设备*/
fd =open("/dev/e2prom",O_RDWR);
if(fd<0){
perror("open failed");
exit(1);
}
/*2. 写数据到e2prom*/
if(strcmp(argv[1],"w")==0){
wbuf[0]=0x05;
wbuf[1]=0x55;
if(write(fd,wbuf,2)<0){
perror("write failed");
exit(1);
}
}
else{
/*4. 从e2prom读数据*/
/*4.1 写片内地址*/
if(write(fd,®ister_addr,1)<0){
perror("write failed");
exit(1);
}
         memset(rbuf,0,10);
/*4.2 读数据*/
if(read(fd,rbuf,1)<0){
perror("read error");
exit(1);
}
printf("read 0x%x from e2prom\n",rbuf[0]);
}
return 0;
}
