---
layout:     post                    # 使用的布局（不需要改）
title:      汇编调用c函数为什么要设置栈                # 标题 
subtitle:    第一篇                  #副标题
date:       2019-08-29              # 时间
author:     BY Edlward              # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - Uboot
---

### 汇编调用c函数为什么要设置栈

一.栈的整体作用

(1)保存现场/上下文

(2)传递参数:汇编代码调用c函数时，需传递参数

(3)保存临时变量:包括函数的非静态局部变量以及编译器自动生成的其他临时变量。

二.为什么汇编代码调用c函数需要设置栈

之前看了很多关于uboot的分析，其中就有说要为C语言的运行，准备好栈。而自己在Uboot的start.S汇编代码中，关于系统初始化，也看到有栈指针初始化这个动作。但是，从来只是看到有人说系统初始化要初始化栈，即正确给栈指针sp赋值，但是却从来没有看到有人解释，为何要初始化栈。所以，接下来的内容，就是经过一定的探究，试图来解释一下，为何要初始化栈。
要明白这个问题，首先要了解栈的作用。关于栈的作用，要详细讲解的话，要很长的篇幅，所以此处只是做简略介绍。总的来说，栈的作用就是：保存现场/上下文，传递参数，保存临时变量

1.保存现场/上下文
现场/上下文，意思就相当于案发现场，总有一些现场的情况，要记录下来的，否则被别人破坏掉之后，你就无法恢复现场了。而此处说的现场，就是指CPU运行的时候，用到了一些寄存器，比如r0,r1等等，对于这些寄存器的值，如果你不保存而直接跳转到子函数中去执行，那么很可能就被其破坏了，因为其函数执行也要用到这些寄存器。因此，在函数调用之前，应该将这些寄存器等现场，暂时保持起来(入栈push)，等调用函数执行完毕返回后(出栈pop)，再恢复现场。这样CPU就可以正确的继续执行了。
保存寄存器的值，一般用的是push指令，将对应的某些寄存器的值，一个个放到栈中，把对应的值压入到栈里面，即所谓的压栈。然后待被调用的子函数执行完毕的时候，再调用pop，把栈中的一个个的值，赋值给对应的那些你刚开始压栈时用到的寄存器，把对应的值从栈中弹出去，即所谓的出栈。
其中保存的寄存器中，也包括lr的值（因为用bl指令进行跳转的话，那么之前的pc的值是存在lr中的），然后在子程序执行完毕的时候，再把栈中的lr的值pop出来，赋值给pc，这样就实现了子函数的正确的返回。

2.传递参数
C语言进行函数调用的时候，常常会传递给被调用的函数一些参数，对于这些C语言级别的参数，被编译器翻译成汇编语言的时候，就要找个地方存放一下，并且让被调用的函数能够访问，否则就没发实现传递参数了。对于找个地方放一下，分两种情况。一种情况是，本身传递的参数不多于4个，就可以通过寄存器传送参数。因为在前面的保存现场的动作中，已经保存好了对应的寄存器的值，那么此时，这些寄存器就是空闲的，可以供我们使用的了，那就可以放参数。另一种情况是，参数多于4个时，寄存器不够用，就得用栈了。

3.临时变量保存在栈中

包括函数的非静态局部变量以及编译器自动生成的其他临时变量。

4.举例分析C语言函数调用是如何使用栈的
对于上面的解释的栈的作用显得有些抽象，此处再用例子来简单说明一下，就容易明白了：用:arm-inux-objdump–d u-boot >dump_u-boot.txt可以得到dump_u-boot.txt文件。该文件就是中，包含了u-boot中的程序的可执行的汇编代码，其中我们可以看到C语言的函数的源代码，到底对应着那些汇编代码。
下面贴出两个函数的汇编代码，一个是clock_init，另一个是与clock_init在同一C源文件中的，另外一个函数CopyCode2Ram：
33d0091c<CopyCode2Ram>:
33d0091c:  e92d4070  push   {r4, r5, r6, lr}
33d00920:  e1a06000  mov r6, r0
33d00924:  e1a05001  mov r5, r1
33d00928:  e1a04002  mov r4, r2
33d0092c:  ebffffef  bl  33d008f0 <bBootFrmNORFlash>
......
33d00984:  ebffff14  bl  33d005dc <nand_read_ll>
......
33d009a8:  e3a00000  mov r0, #0 ; 0x0
33d009ac:  e8bd8070  pop {r4, r5, r6, pc}
33d009b0<clock_init>:
33d009b0:  e3a02313  mov r2, #1275068416   ;0x4c000000
33d009b4:  e3a03005  mov r3, #5 ; 0x5
33d009b8:  e5823014  str r3, 
......
33d009f8:  e1a0f00e  mov pc, lr
（1）clock_init部分的代码可以看到该函数第一行：33d009b0:  e3a02313  mov r2, #1275068416   ;0x4c000000就没有我们所期望的push指令，没有去将一些寄存器的值放到栈中。这是因为，我们clock_init这部分的内容，所用到的r2,r3等等寄存器，和前面调用clock_init之前所用到的寄存器r0，没有冲突，所以此处可以不用push去保存这类寄存器的值，不过有个寄存器要注意，那就是r14，即lr，其是在前面调用clock_init的时候，用的是bl指令，所以会自动把跳转时候的pc的值赋值给lr，所以也不需要push指令去将PC的值保存到栈中。而clock_init的代码的最后一行:33d009f8:e1a0f00e mov pc, lr就是我们常见的movpc,lr，把lr的值，即之前保存的函数调用时候的PC值，赋值给现在的PC，这样就实现了函数的正确的返回，即返回到了函数调用时候下一个指令的位置。这样CPU就可以继续执行原先函数内剩下那部分的代码了。
（2）CopyCode2Ram部分的代码其第一行：33d0091c:e92d4070 push {r4, r5, r6, lr}就是我们所期望的，用push指令，保存了r4,r5,r以及lr。用push去保存r4,r5,r6，那是因为所谓的保存现场，以后后续函数返回时候再恢复现场，而用push去保存lr，那是因为此函数里面，还有其他函数调用：33d0092c:  ebffffef  bl  33d008f0 <bBootFrmNORFlash>
......
33d00984:  ebffff14  bl  33d005dc <nand_read_ll>
......也用到了bl指令，会改变我们最开始进入clock_init时候的lr的值，所以我们要用push也暂时保存起来。而对应地，CopyCode2Ram的最后一行：33d009ac:e8bd8070 pop {r4, r5, r6,pc}就是把之前push的值，给pop出来，还给对应的寄存器，其中最后一个是将开始push的lr的值，pop出来给赋给PC，因为实现了函数的返回。另外，我们注意到，在CopyCode2Ram的倒数第二行是：33d009a8:e3a00000 mov r0, #0 ;0x0是把0赋值给r0寄存器，这个就是我们所谓返回值的传递，是通过r0寄存器的。此处的返回值是0，也对应着C语言的源码中的“return0”.
对于使用哪个寄存器来传递返回值：当然你也可以用其他暂时空闲没有用到的寄存器来传递返回值，但是这些处理方式，本身是根据ARM的APCS的寄存器的使用的约定而设计的，你最好不要随便改变使用方式，最好还是按照其约定的来处理，这样程序更加符合规范。
